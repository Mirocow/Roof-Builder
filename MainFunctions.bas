Attribute VB_Name = "MainFunctions"
'
' Методы сортировок
'

''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом пузырька
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BubbleSort(ByRef Arr() As Long, ByRef N As Long)
    Dim I As Long
    Dim J As Long
    Dim Tmp As Double

    For I = 0# To N - 1# Step 1
        For J = 0# To N - 2# - I Step 1
            If Arr(J) < Arr(J + 1#) Then
                Tmp = Arr(J)
                Arr(J) = Arr(J + 1#)
                Arr(J + 1#) = Tmp
            End If
        Next J
    Next I
End Sub



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом выборки
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub SelectionSort(ByRef Arr() As Long, ByRef N As Long)
    Dim I As Long
    Dim J As Long
    Dim K As Long
    Dim m As Double

    For I = 1# To N Step 1
        m = Arr(I - 1#)
        K = I
        For J = I To N Step 1
            If m > Arr(J - 1#) Then
                m = Arr(J - 1#)
                K = J
            End If
        Next J
        Arr(K - 1#) = Arr(I - 1#)
        Arr(I - 1#) = m
    Next I
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом вставок
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub InsertionSort(ByRef Arr() As Long, ByVal N As Long)
    Dim I As Long
    Dim J As Long
    Dim K As Long
    Dim Tmp As Double

    N = N - 1#
    I = 1#
    Do
        J = 0#
        Do
            If Arr(I) <= Arr(J) Then
                K = I
                Tmp = Arr(I)
                Do
                    Arr(K) = Arr(K - 1#)
                    K = K - 1#
                Loop Until Not K > J
                Arr(J) = Tmp
                J = I
            Else
                J = J + 1#
            End If
        Loop Until Not J < I
        I = I + 1#
    Loop Until Not I <= N
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом двоичных вставок
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub BinaryInsertionSort(ByRef Arr() As Long, ByVal N As Long)
    Dim B As Long
    Dim C As Long
    Dim E As Long
    Dim I As Long
    Dim J As Long
    Dim K As Long
    Dim Tmp As Double

    I = 2#
    Do
        B = 1#
        E = I - 1#
        C = (B + E) \ 2#
        Do While B <> C
            If Arr(C - 1#) > Arr(I - 1#) Then
                E = C
            Else
                B = C
            End If
            C = (B + E) \ 2#
        Loop
        If Arr(B - 1#) < Arr(I - 1#) Then
            If Arr(I - 1#) > Arr(E - 1#) Then
                B = E + 1#
            Else
                B = E
            End If
        End If
        K = I
        Tmp = Arr(I - 1#)
        Do While K > B
            Arr(K - 1#) = Arr(K - 1# - 1#)
            K = K - 1#
        Loop
        Arr(B - 1#) = Tmp
        I = I + 1#
    Loop Until Not I <= N
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом Шелла
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ShellSort(ByRef Arr() As Long, ByVal N As Long)
    Dim C As Boolean
    Dim E As Long
    Dim G As Long
    Dim I As Long
    Dim J As Long
    Dim Tmp As Double

    N = N - 1#
    G = (N + 1#) \ 2#
    Do
        I = G
        Do
            J = I - G
            C = True
            Do
                If Arr(J) <= Arr(J + G) Then
                    C = False
                Else
                    Tmp = Arr(J)
                    Arr(J) = Arr(J + G)
                    Arr(J + G) = Tmp
                End If
                J = J - 1#
            Loop Until Not (J >= 0# And C)
            I = I + 1#
        Loop Until Not I <= N
        G = G \ 2#
    Loop Until Not G > 0#
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом Флойда
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub HeapSort(ByRef Arr() As Long, ByVal N As Long)
    Dim I As Long
    Dim J As Long
    Dim K As Long
    Dim T As Long
    Dim Tmp As Double

    If N = 1# Then
        Exit Sub
    End If
    I = 2#
    Do
        T = I
        Do While T <> 1#
            K = T \ 2#
            If Arr(K - 1#) >= Arr(T - 1#) Then
                T = 1#
            Else
                Tmp = Arr(K - 1#)
                Arr(K - 1#) = Arr(T - 1#)
                Arr(T - 1#) = Tmp
                T = K
            End If
        Loop
        I = I + 1#
    Loop Until Not I <= N
    I = N - 1#
    Do
        Tmp = Arr(I)
        Arr(I) = Arr(0#)
        Arr(0#) = Tmp
        T = 1#
        Do While T <> 0#
            K = 2# * T
            If K > I Then
                T = 0#
            Else
                If K < I Then
                    If Arr(K) > Arr(K - 1#) Then
                        K = K + 1#
                    End If
                End If
                If Arr(T - 1#) >= Arr(K - 1#) Then
                    T = 0#
                Else
                    Tmp = Arr(K - 1#)
                    Arr(K - 1#) = Arr(T - 1#)
                    Arr(T - 1#) = Tmp
                    T = K
                End If
            End If
        Loop
        I = I - 1#
    Loop Until Not I >= 1#
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Процедура для сортировки массива методом фон Неймана (слияний)
'
'Входные параметры:
'    Arr -   сортируемый массив.
'            Нумерация элементов от 0 до N-1
'    N   -   размер массива
'
'Выходные параметры:
'    Arr -   массив, упорядоченный по возрастанию.
'            Нумерация элементов от 0 до N-1
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub NeumanSort(ByRef Arr() As Long, ByVal N As Long)
    Dim C As Boolean
    Dim I As Long
    Dim I1 As Long
    Dim I2 As Long
    Dim N1 As Long
    Dim N2 As Long
    Dim J As Long
    Dim K As Long
    Dim Tmp As Double
    Dim BArr() As Double
    Dim MergeLen As Long

    ReDim BArr(0# To N - 1#)
    MergeLen = 1#
    C = True
    Do While MergeLen < N
        If C Then
            I = 0#
            Do While I + MergeLen <= N
                I1 = I + 1#
                I2 = I + MergeLen + 1#
                N1 = I + MergeLen
                N2 = I + 2# * MergeLen
                If N2 > N Then
                    N2 = N
                End If
                Do While I1 <= N1 Or I2 <= N2
                    If I1 > N1 Then
                        Do While I2 <= N2
                            I = I + 1#
                            BArr(I - 1#) = Arr(I2 - 1#)
                            I2 = I2 + 1#
                        Loop
                    Else
                        If I2 > N2 Then
                            Do While I1 <= N1
                                I = I + 1#
                                BArr(I - 1#) = Arr(I1 - 1#)
                                I1 = I1 + 1#
                            Loop
                        Else
                            If Arr(I1 - 1#) > Arr(I2 - 1#) Then
                                I = I + 1#
                                BArr(I - 1#) = Arr(I2 - 1#)
                                I2 = I2 + 1#
                            Else
                                I = I + 1#
                                BArr(I - 1#) = Arr(I1 - 1#)
                                I1 = I1 + 1#
                            End If
                        End If
                    End If
                Loop
            Loop
            I = I + 1#
            Do While I <= N
                BArr(I - 1#) = Arr(I - 1#)
                I = I + 1#
            Loop
        Else
            I = 0#
            Do While I + MergeLen <= N
                I1 = I + 1#
                I2 = I + MergeLen + 1#
                N1 = I + MergeLen
                N2 = I + 2# * MergeLen
                If N2 > N Then
                    N2 = N
                End If
                Do While I1 <= N1 Or I2 <= N2
                    If I1 > N1 Then
                        Do While I2 <= N2
                            I = I + 1#
                            Arr(I - 1#) = BArr(I2 - 1#)
                            I2 = I2 + 1#
                        Loop
                    Else
                        If I2 > N2 Then
                            Do While I1 <= N1
                                I = I + 1#
                                Arr(I - 1#) = BArr(I1 - 1#)
                                I1 = I1 + 1#
                            Loop
                        Else
                            If BArr(I1 - 1#) > BArr(I2 - 1#) Then
                                I = I + 1#
                                Arr(I - 1#) = BArr(I2 - 1#)
                                I2 = I2 + 1#
                            Else
                                I = I + 1#
                                Arr(I - 1#) = BArr(I1 - 1#)
                                I1 = I1 + 1#
                            End If
                        End If
                    End If
                Loop
            Loop
            I = I + 1#
            Do While I <= N
                Arr(I - 1#) = BArr(I - 1#)
                I = I + 1#
            Loop
        End If
        MergeLen = 2# * MergeLen
        C = Not C
    Loop
    If Not C Then
        I = 1#
        Do
            Arr(I - 1#) = BArr(I - 1#)
            I = I + 1#
        Loop Until Not I <= N
    End If
End Sub


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Функция   для поиска k-ого по величине элемента массива.
'Параметры:
'    *M - массив элементов с индексами от 0 до N-1
'    *N - число элементов
'    *K - номер искомого элемента
'Результат:
'    *Значение K-ого по величине элемента.   K  принимает
'     значения в диапазоне от 0 до N-1, где нулю соответ-
'     ствует наименьший элемент, N-1 - наибольший.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function KthElement(ByRef MArr_() As Long, _
         ByVal N As Long, _
         ByVal K As Long) As Double
    Dim Result As Double
    Dim MArr() As Double
    Dim I As Long
    Dim J As Long
    Dim L As Long
    Dim NM As Long
    Dim MM As Long
    Dim KM As Long
    Dim med As Double
    Dim Tmp As Double
    Dim Tmp2 As Double
    Dim LArr() As Double
    Dim MergeLen As Long
    MArr = MArr_

    ReDim LArr(0# To N - 1#)
    K = K + 1#
    Do While N > 5#
        I = 1#
        Do
            LArr(I - 1#) = MArr(I - 1#)
            I = I + 1#
        Loop Until Not I <= N
        NM = N
        Do While NM > 5#
            MM = NM \ 5#
            I = 1#
            Do
                KM = (I - 1#) * 5#
                J = 1#
                Do
                    L = 1#
                    Do
                        If LArr(KM + L - 1#) > LArr(KM + L - 1#) Then
                            Tmp = LArr(KM + L - 1#)
                            LArr(KM + L - 1#) = LArr(KM + L)
                            LArr(KM + L) = Tmp
                        End If
                        L = L + 1#
                    Loop Until Not L <= 5# - J
                    J = J + 1#
                Loop Until Not J <= 5#
                LArr(I - 1#) = LArr(KM + 2#)
                I = I + 1#
            Loop Until Not I <= MM
            KM = MM * 5#
            NM = NM - KM
            If NM > 0# Then
                MM = MM + 1#
                If NM > 1# Then
                    J = 1#
                    Do
                        L = 1#
                        Do
                            If LArr(KM + L - 1#) > LArr(KM + L) Then
                                Tmp = LArr(KM + L - 1#)
                                LArr(KM + L - 1#) = LArr(KM + L)
                                LArr(KM + L) = Tmp
                            End If
                            L = L + 1#
                        Loop Until Not L <= NM - J
                        J = J + 1#
                    Loop Until Not J <= NM
                End If
                LArr(MM - 1#) = LArr(KM)
            End If
            NM = MM
        Loop
        If NM <> 1# Then
            J = 1#
            Do
                L = 1#
                Do
                    If LArr(L - 1#) > LArr(L) Then
                        Tmp = LArr(L - 1#)
                        LArr(L - 1#) = LArr(L)
                        LArr(L) = Tmp
                    End If
                    L = L + 1#
                Loop Until Not L <= NM - J
                J = J + 1#
            Loop Until Not J <= NM
            If NM >= 3# Then
                med = LArr(1#)
            Else
                med = LArr(0#)
            End If
        Else
            med = LArr(0#)
        End If
        I = 1#
        J = N
        Do While I <> J
            If MArr(I - 1#) > med Then
                Do While MArr(J - 1#) > med And I <> J
                    J = J - 1#
                Loop
                If I <> J Then
                    Tmp2 = MArr(I - 1#)
                    MArr(I - 1#) = MArr(J - 1#)
                    MArr(J - 1#) = Tmp2
                    I = I + 1#
                End If
            Else
                I = I + 1#
            End If
        Loop
        If K >= J Then
            I = J
            Do
                MArr(I - J) = MArr(I - 1#)
                I = I + 1#
            Loop Until Not I <= N
            N = N - J + 1#
            K = K - J + 1#
        Else
            N = J - 1#
        End If
    Loop
    If N <> 1# Then
        I = 1#
        Do
            J = 1#
            Do
                If MArr(J - 1#) > MArr(J) Then
                    Tmp2 = MArr(J - 1#)
                    MArr(J - 1#) = MArr(J)
                    MArr(J) = Tmp2
                End If
                J = J + 1#
            Loop Until Not J <= N - I
            I = I + 1#
        Loop Until Not I <= N
        Result = MArr(K - 1#)
    Else
        Result = MArr(0#)
    End If

    KthElement = Result
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Функция для поиска наименьшего элемента.
'Принимает:
'    *массив значений a с индексами элементов от 0 до N-1
'    *число элементов N
'Возвращает:
'    *номер наименьшего элемента
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function FindLeastElement(ByRef A() As Long, ByRef N As Long) As Long
    Dim Result As Long
    Dim I As Long

    Result = 0#
    For I = 1# To N - 1# Step 1
        If A(Result) > A(I) Then
            Result = I
        End If
    Next I

    FindLeastElement = Result
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'This code is generated by the AlgoPascal translator
'
'This code is distributed under the ALGLIB license
'    (see http://www.alglib.net/copyrules.php for details)
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Routines
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Поиск в упорядоченной последовательности первого элемента,
'не меньшего, чем T.
'
'Параметры:
'    A - упорядоченный по возрастанию массив элементов с
'        индексами от 0 до N-1
'    N - число элементов в массиве
'    T - искомый элемент
'
'Результат:
'    Индекс самого первого элемента, не меньшего T. В случае,
'если таких элементов в массиве нет, возвращается N.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function LowerBound(ByRef A() As Long, _
         ByRef N As Long, _
         ByRef T As Double) As Long
    Dim Result As Long
    Dim L As Long
    Dim Half As Long
    Dim First As Long
    Dim Middle As Long

    L = N
    First = 0#
    Do While L > 0#
        Half = L \ 2#
        Middle = First + Half
        If A(Middle) < T Then
            First = Middle + 1#
            L = L - Half - 1#
        Else
            L = Half
        End If
    Loop
    Result = First

    LowerBound = Result
End Function


''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
'Поиск в упорядоченной последовательности первого элемента,
'большего, чем T.
'
'Параметры:
'    A - упорядоченный по возрастанию массив элементов с
'        индексами от 0 до N-1
'    N - число элементов в массиве
'    T - искомый элемент
'
'Результат:
'    Индекс первого элемента, большего T. В случае,
'если таких элементов в массиве нет, возвращается N.
'
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Function UpperBound(ByRef A() As Long, _
         ByRef N As Long, _
         ByRef T As Double) As Long
    Dim Result As Long
    Dim L As Long
    Dim Half As Long
    Dim First As Long
    Dim Middle As Long

    L = N
    First = 0#
    Do While L > 0#
        Half = L \ 2#
        Middle = First + Half
        If T < A(Middle) Then
            L = Half
        Else
            First = Middle + 1#
            L = L - Half - 1#
        End If
    Loop
    Result = First

    UpperBound = Result
End Function




